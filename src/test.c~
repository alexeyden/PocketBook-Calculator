#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include "inkview.h"

#define uint unsigned int
#define ushort unsigned short

#define SCREEN_PADDING 4
#define LINE_SPACING 2

ifont *font = NULL;

#define MENU_SELECT 1
#define MENU_EDIT 2
#define MENU_DELETE 3

imenu app_menu[] = {
	{ ITEM_HEADER, 0, "Action", NULL },
	{ ITEM_ACTIVE, MENU_SELECT, "Select", NULL },
	{ ITEM_ACTIVE, MENU_EDIT  , "Edit",   NULL },
	{ ITEM_ACTIVE, MENU_DELETE, "Delete", NULL }
};

char* screenbuf = NULL;
unsigned screenbuf_width = 0;
unsigned screenbuf_height = 0;
unsigned text_height = 0;

bool is_selecting = false;
char* sel_pos1 = NULL;
char* sel_pos2 = NULL;

/*
size_t screenbuf_length() {
	size_t length = 0;
	for(unsigned short line = 0; line < screenbuf_height; line++)
		length+=strlen(screenbuf[line]);
	return length;
}
*/
/*
char* screenbuf_insert(unsigned short line, unsigned short column, const char* string) {
	if(screenbuf_length() + strlen(string) > screenbuf_height*screenbuf_width)
		return NULL;
	unsigned str_shift = strlen(string);
	char* tmp_str = (char*) malloc((screenbuf_width+strlen(string))*sizeof(char));
	char* pos = tmp_str;
	memcpy(tmp_str, screenbuf[line], column);
	memcpy(tmp_str+column, string, strlen(string));
	memcpy(tmp_str+column+strlen(string), screenbuf[line]+column, strlen(screenbuf[line]+column));
	
	memcpy(screenbuf[line],tmp_str, screenbuf_width);
	screenbuf[line][screenbuf_width] = '\0';
	while(str_shift > 0) {
		
	}
}
*/

char* screenbuf_row(ushort row_n) {
	return screenbuf + row_n*(screenbuf_width+1);
}

unsigned short screenbuf_row_n(const char* pos) {
	return (pos - screenbuf)/(screenbuf_width+1);
}

unsigned short screenbuf_col_n(const char* pos) {
	return (pos - screenbuf)%(screenbuf_width+1);
}

unsigned screenbuf_char_x(const char* pos) {
	ushort col = screenbuf_col_n(pos);

	return CharWidth('A')*col + SCREEN_PADDING;
}

unsigned screenbuf_char_y(const char* pos) {
	ushort row = screenbuf_row_n(pos);
	
	return (text_height+LINE_SPACING)*row + SCREEN_PADDING;
}

bool screenbuf_ptr_valid(const char* pos) {
	if(pos >= screenbuf+(screenbuf_width+1)*screenbuf_height ||
		pos < screenbuf)
		return false;
	else
		return true;
}

char* screenbuf_char_at(unsigned x, unsigned y) {
	return NULL;
}

void app_init() {
	font = OpenFont(DEFAULTFONTM, 12, 1);
	SetFont(font, BLACK);
	
	int sw = ScreenWidth();
	int sh = ScreenHeight();
	text_height = TextRectHeight(20, "A", 0);
	screenbuf_width = (sw-SCREEN_PADDING*2)/CharWidth('A');
	screenbuf_height = (sh-SCREEN_PADDING*2)/(text_height + LINE_SPACING);
	
	screenbuf = (char*) malloc(screenbuf_height * (screenbuf_width+1) * sizeof(char));
	memset(screenbuf,' ',screenbuf_height*(screenbuf_width+1));
	for(unsigned short i = 0; i < screenbuf_height; i++)
		screenbuf[(screenbuf_width+1)*i+screenbuf_width] = '\0';
	
	fill_test_buf();
	
	ClearScreen();
}

void fill_test_buf() {
	char* buf[7] = {
		"hello world",
		"some cool",
		"things a lot",
		"mothafucka kinda very long text so cool motha",
		"this is 5th line, mothafucker",
		"русссикй тескств лололколуколуокл",
		"ohohh numbers alot 132290492049"
	};
	for(ushort i = 0; i < 7; i++) {
		memset(screenbuf + (screenbuf_width+1)*i, '\0', screenbuf_width+1);
		strcpy(screenbuf + (screenbuf_width+1)*i, buf[i]);
	}
}

void app_exit() {
	free(screenbuf);
	CloseFont(font);
}

void app_on_menu(int index) {
	switch(index) {
		case MENU_SELECT:
			is_selecting = true;
			sel_pos1 = screenbuf;
			draw_selection(sel_pos1, sel_pos1);
			break;
		case MENU_EDIT:
			break;
		case MENU_DELETE:
			break;
		default:
			break;
	}
}

void app_on_keypress(int keycode) {
	switch(keycode) {
		case KEY_OK:
			break;
		case KEY_BACK:
			CloseApp();
			break;
		case KEY_UP:
			break;
		case KEY_DOWN:
			break;
		case KEY_LEFT:
	
			break;
		case KEY_RIGHT:
			break;
		default: break;
	}
}

void app_screen_redraw() {
  ClearScreen();
  //DrawSelection(SCREEN_PADDING, SCREEN_PADDING, ScreenWidth() - SCREEN_PADDING*2, ScreenHeight() - SCREEN_PADDING*2, BLACK);
  draw_screenbuf();
  if(is_selecting)
	  draw_selection(sel_pos1, sel_pos2);
  FullUpdate();

}

void app_on_edit(const char *str) {
  app_screen_redraw();
}

int app_on_event(int type, int param1, int param2) {
	switch(type) {
		case EVT_INIT:
			app_init();
			break;
		case EVT_SHOW:
			app_screen_redraw();
			break;
		case EVT_KEYPRESS:
			app_on_keypress(param1);
			break;
		case EVT_EXIT:
			app_exit();
			break;
		default: break;
	}
	
	return 0;
}

int main(int argc, const char** argv) {
	InkViewMain(app_on_event);
	
	return 0;
}
