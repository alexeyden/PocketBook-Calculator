#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include "inkview.h"

#define uint unsigned int
#define ushort unsigned short

using std::string;
using std::vector;

ifont *font = NULL;

/***********************************************************************************/

class Widget {
public:
	Widget() {
		this->m_id = m_last_id++;
		this->m_label = "";
		this->m_x = 0;
		this->m_y = 0;
		this->m_w = 0;
		this->m_h = 0;
		
		m_all_widgets.push_back(this);
	}
	
	Widget(const string& label, unsigned x, unsigned y, unsigned w, unsigned h) {
		this->m_id = m_last_id++;
		this->m_label = label;
		this->m_x = x;
		this->m_y = y;
		this->m_w = w;
		this->m_h = h;
		
		m_all_widgets.push_back(this);
	}
	
	virtual ~Widget() {
		for(vector<Widget*>::iterator it = m_all_widgets.begin(); it != m_all_widgets.end(); it++)
			if((*it) == this) {
				m_all_widgets.erase(it);
				break;
			}
			
		if(Widget::m_focus == this)
			m_focus = NULL;
	}
	
	virtual void draw() = 0;
	
	virtual void update() {
		PartialUpdate(m_x, m_y, m_w, m_h);
	}
	
	unsigned getID() const {
		return this->m_id;
	}
	
	const string& getLabel() const {
		return this->m_label;
	}
	
	unsigned getX() const {
		return m_x;
	}
	
	unsigned getY() const {
		return m_y;
	}
	
	unsigned getWidth() const {
		return m_w;
	}
	
	unsigned getHeight() const {
		return m_h;
	}
	
	virtual unsigned getMinWidth() const = 0;
	virtual unsigned getMinHeight() const = 0;
	
	void setSize(unsigned w, unsigned h) {
		this->m_w = w;
		this->m_h = h;
	}
	
	void setPos(unsigned x, unsigned y) {
		this->m_x = x;
		this->m_y = y;
	}
	
	static void processEvent(unsigned id, unsigned param1, unsigned param2) {
		if(id == EVT_KEYRELEASE) {
			if(m_focus) {
				m_focus->onKeyUp(param1);
			}
		} else if(id == EVT_POINTERDOWN) {
			for(size_t i = 0; i < m_all_widgets.size(); i++) {
				if(param1 >= m_all_widgets[i]->m_x && param2 >= m_all_widgets[i]->m_y && 
					param1 < (m_all_widgets[i]->m_x + m_all_widgets[i]->m_w) && 
					param2 < (m_all_widgets[i]->m_y + m_all_widgets[i]->m_h)
				){
					m_all_widgets[i]->onTouchDown(param1, param2);
					break;
				}
			}
		}
	}
	
	static void drawAll() {
		for(size_t i = 0; i < m_all_widgets.size(); i++) {
			m_all_widgets[i]->draw();
		}
	}
	
	static void setFocus(Widget* focus, bool update=false) {
		Widget* tmp = m_focus;
		m_focus = focus;
		
		if(tmp && update) {
			tmp->draw();
			tmp->update();
		}
	}
	
	static Widget* getFocus() {
		return m_focus;
	}
	
	static void setFont(ifont* widgets_font) {
		m_font = widgets_font;
	}
	
	static const ifont* getFont() {
		return m_font;
	}
	
protected:
	virtual void onTouchDown(unsigned x, unsigned y) = 0;
	virtual void onKeyUp(unsigned key) = 0;
	
	string m_label;
	
	unsigned m_x;
	unsigned m_y;
	unsigned m_w;
	unsigned m_h;
	static Widget* m_focus;
	
	static ifont* m_font;
private:
	unsigned m_id;
	static unsigned m_last_id;
	
	static vector<Widget*> m_all_widgets;
};

ifont* Widget::m_font = NULL;
unsigned Widget::m_last_id = 0;
vector<Widget*> Widget::m_all_widgets;
Widget* Widget::m_focus = NULL;

class Separator : public Widget {
public:
	Separator(unsigned width, unsigned height)
		: Widget("_sep", 0, 0, width, height) {}

	unsigned getMinWidth() const {
		return m_w;
	}
	
	unsigned getMinHeight() const {
		return m_h;
	}
	
	void draw() {}
	void update() {}
};

class GridLayout {
public:
	GridLayout(unsigned x, unsigned y, unsigned rows, unsigned cols,
			   unsigned width, unsigned height, unsigned sp) : 
		m_widgets(rows), m_x(x), m_y(y), m_width(width), m_height(height), m_spacing(sp)
	{
		for(size_t i = 0; i < rows; i++) {
			m_widgets[i].resize(cols);
			
			for(size_t j = 0; j < cols; j++)
				m_widgets[i][j] = NULL;
		}
	}
	
	bool append(const Widget* widget) {
		for(size_t i = 0; i < m_widgets.size(); i++) {	
			for(size_t j = 0; j < m_widgets[0].size(); j++)
				if(m_widgets[i][j] == NULL) {
					m_widgets[i][j] = const_cast<Widget*>(widget);
					
					return true;
				}
		}
		return false;
	}
	
	void insert(const Widget* widget, unsigned row, unsigned col) {
		m_widgets[row][col] = const_cast<Widget*>(widget);
	}
	
	const vector<Widget*>& operator[](unsigned row) const {
		return m_widgets[row];
	}
	
	unsigned getWidth() const {
		return m_width;
	}
	
	unsigned getHeight() const {
		return m_height;
	}
	
	void update() {
		unsigned x_paddings = (m_widgets[0].size()) ? m_widgets[0].size()-1 : 0;
		unsigned y_paddings = (m_widgets.size()) ? m_widgets.size()-1 : 0;
		unsigned opt_width = (m_width - m_spacing*x_paddings) / m_widgets[0].size();
		unsigned opt_height = (m_height - m_spacing*y_paddings) / m_widgets.size();
		
		unsigned row_height = 0;
		unsigned col_width = 0;
		
		unsigned x, y;
		
		SetFont(const_cast<ifont*>(Widget::getFont()), BLACK);
		
		y = 0;
		for(unsigned row = 0; row < m_widgets.size(); row++) {
			x = 0;
			row_height = getMinRowHeight(row);
			if(row_height && row_height < opt_height)
				row_height = opt_height;
			
			for(unsigned col = 0; col < m_widgets[0].size(); col++) {
				col_width = getMinColWidth(col);
				if(col_width && col_width < opt_width)
					col_width = opt_width;
				
				if(m_widgets[row][col]) {
					m_widgets[row][col]->setPos(
						m_x + x + (col ? m_spacing : 0 ),
						m_y + y + (row ? m_spacing : 0 )
					);
					
					m_widgets[row][col]->setSize(col_width, row_height);
				}
				
				x+= (col ? m_spacing : 0) + col_width;
			}
			
			y += (row ? m_spacing : 0 ) + row_height;
		}
	}
	
	void __debug_draw() {
		unsigned m_w = m_width;
		unsigned m_h = m_height;
		DrawRect(m_x, m_y, m_width, m_height, LGRAY);
		PartialUpdate(m_x, m_y, m_w, 1);
		PartialUpdate(m_x, m_y, 1, m_h);
		PartialUpdate(m_x, m_h, m_w, 1);
		PartialUpdate(m_w, m_y, 1, m_h);
	}
	
private:
	static bool cmpMinHeight(const Widget* x1, const Widget* x2) {
		unsigned h1 = ((x1) ? (x1->getMinHeight()) : 0);
		unsigned h2 = ((x2) ? (x2->getMinHeight()) : 0);
		return h1 < h2;
	}
	static struct cmpWidth_t{
		unsigned col;
		bool operator()(const vector<Widget*>& x1, const vector<Widget*>& x2) {
			unsigned w1 = ((x1[col]) ? (x1[col]->getMinWidth()) : 0);
			unsigned w2 = ((x2[col]) ? (x2[col]->getMinWidth()) : 0);
			return w1 < w2;
		}
	}cmpMinWidth;
	
	unsigned getMinRowHeight(unsigned row) {
		Widget* w = (*std::max_element(m_widgets[row].begin(), m_widgets[row].end(), cmpMinHeight));
		return ((w) ? w->getMinHeight() : 0);
	}
	
	unsigned getMinColWidth(unsigned col) {		
		cmpMinWidth.col = col;
		Widget* w = (*std::max_element(m_widgets.begin(), m_widgets.end(), cmpMinWidth))[col];
		return ((w) ? w->getMinWidth() : 0);
	}
	
	vector<vector<Widget*> > m_widgets;
	unsigned m_x;
	unsigned m_y;
	unsigned m_width;
	unsigned m_height;
	unsigned m_spacing;
};

GridLayout::cmpWidth_t GridLayout::cmpMinWidth = { 0 };

class Button : public Widget {
public:
	Button(const string& label) : 
		Widget(label, 0, 0, 0, 0) {}
	
	Button(const string& label, unsigned x, unsigned y, unsigned w, unsigned h) : 
		Widget(label, x, y, w, h) {}
	
	void draw() {
		if(m_focus == this)
			SetFont(m_font, WHITE);
		else
			SetFont(m_font, BLACK);
	
		if(m_focus == this)
			FillArea(m_x, m_y, m_w, m_h, BLACK);
		else {
			FillArea(m_x, m_y, m_w, m_h, WHITE);
			DrawRect(m_x, m_y, m_w, m_h, BLACK);
		}
		
		DrawTextRect(
			m_x + m_padding, m_y + m_padding,
			m_w - m_padding, m_h - m_padding,
			m_label.c_str(), ALIGN_CENTER | VALIGN_MIDDLE
		);
	}
	
	unsigned getMinWidth() const {
		SetFont(m_font, BLACK);
		return StringWidth(m_label.c_str()) + 2*m_padding;
	}
	
	unsigned getMinHeight() const {
		SetFont(m_font, BLACK);
		return TextRectHeight(40, "#", ALIGN_LEFT) + 2*m_padding;
	}
	
private:
	void onTouchDown(unsigned x, unsigned y) {
		setFocus(this, true);
		InvertArea(m_x, m_y, m_w, m_h);
		update();
	}
	
	void onKeyUp(unsigned key) {
	}
	
	static const ushort m_padding = 4;
};

class TextBox : public Widget {
public:
	TextBox() : Widget("__textbox") {
	}
	
	void draw() {
		SetFont(m_focus, BLACK);
		FillArea(m_x, m_y, m_width, m_height, WHITE);
		DrawRect(m_x, m_y, m_width, m_height, BLACK);
		//DrawTextRect(e->x+4, e->y+4, e->width-4, e->height-4, e->text.c_str(), ALIGN_LEFT);
		
		string tmp;
		unsigned i = 0, yi = 0;
		unsigned dy = TextRectHeight(20, "#", 0);
		unsigned pos_x = 0, pos_y = 0;
		//TODO: break line only on operators, if possible + tune perf
		while(i < m_words.size() && yi < (m_h - 8)/dy) {
			while(i < e->words.size() && CharWidth('#')*(tmp.size() + e->words[i].size()) < e->width - 8) {
				if(i == e->pos) {
					pos_x = e->x + 4 + tmp.size()*CharWidth('#');
					pos_y = e->y + 4 + yi*dy;
				}
				
				if(i == e->words.size() - 1 && e->pos > i) {
					pos_x = e->x + 4 + (tmp.size() + e->words[i].size())*CharWidth('#');
					pos_y = e->y + 4 + yi*dy;
				}
				
				tmp.append(e->words[i++]);
			}
			
			DrawString(e->x + 4, e->y + 4 + yi*dy, tmp.c_str());
			
			yi++;
			tmp.clear();
		}
		
		if(draw_pos) {
			DrawLine(pos_x, pos_y, pos_x, pos_y + dy, BLACK);
		}
		
		if(update) {
			DynamicUpdateBW(e->x, e->y, e->width, e->height);
		}
	}
private:
	unsigned m_pos;
	vector<string> m_words;
};

/* ******************************** MAIN *****************************************/
GridLayout* l;
void app_init() {
	font = OpenFont(DEFAULTFONTM, 12, 1);
	Widget::setFont(font);
	 l = new GridLayout(50, 50, 4, 2, 400, 400, 8);
	l->append(new Button("(1,1)")); l->append(new Button("(1,2)"));
	l->insert(NULL, 1, 0); l->insert(NULL, 1, 1);
	//l->append(new Button("(1,3)"));
	//l->append(new Button("(1,4)"));
	//l->append(new Button("(2,1)"));
	l->insert(new Button("(2,2)"), 2, 0); l->insert(new Button("(2,3)"), 2, 1);
	l->insert(new Button("(2,4)") ,3, 0);
	
	l->update();
	
	ClearScreen();
}
void app_exit() {
	CloseFont(font);
}

void app_on_keypress(int keycode) {
	switch(keycode) {
		case KEY_OK:
			break;
		case KEY_BACK:
			CloseApp();
			break;
		case KEY_UP:
			break;
		case KEY_DOWN:
			break;
		case KEY_LEFT:
	
			break;
		case KEY_RIGHT:
			break;
		default: break;
	}
}

void app_screen_redraw() {
  ClearScreen();
  l->__debug_draw();
  Widget::drawAll();
  FullUpdate();
}

int app_on_event(int type, int param1, int param2) {
	switch(type) {
		case EVT_INIT:
			app_init();
			break;
		case EVT_SHOW:
			app_screen_redraw();
			break;
		case EVT_KEYPRESS:
			app_on_keypress(param1);
			break;
		case EVT_POINTERDOWN:
		case EVT_POINTERUP:
			Widget::processEvent(type, param1, param2);
			break;
		case EVT_EXIT:
			app_exit();
			break;
		default: break;
	}
	
	return 0;
}

int main(int argc, const char** argv) {
	InkViewMain(app_on_event);
	
	return 0;
}
